# -*- coding: utf-8 -*-
"""Multithreadind_and_multiprocessing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hKuynceR6Tv0qySDPPT6JDYVE8s40aq7
"""

import time
import threading
def some_task():
  for i in range(1,10000000):
    s=5**999
    #time.sleep(1)
  print(s)
if __name__ == "__main__":
    start = time.time()
    # Create two threads
    t1 = threading.Thread(target=some_task)
    t2 = threading.Thread(target=some_task)
    # Start running both threads
    t1.start()
    t2.start()
    # Wait until both threads are complete, and join the process into a single thread
    t1.join()
    t2.join()
    end = time.time()
    print(f"Finished process in {end - start} seconds")

import time
import multiprocessing
def some_task():
    for _ in range(10000000):
        x = 5**999
    print(x)
    print("Finished task")
if __name__ == "__main__":
    start = time.time()
    # Create two threads
    p1 = multiprocessing.Process(target=some_task)
    p2 = multiprocessing.Process(target=some_task)
    # Start running both threads
    p1.start()
    p2.start()
    # Wait until both threads are complete, and join the process into a single thread
    p1.join()
    p2.join()
    end = time.time()
    print(f"Finished process in {end - start} seconds")



"""Multithreading and multiprocessing are both techniques used to achieve concurrent execution of tasks, but they differ in how they distribute and manage computational resources. Here's an overview of the differences between multithreading and multiprocessing:

Multithreading:

Multithreading refers to the ability of an operating system or programming language to manage multiple threads within a single process. Threads are lightweight and share the same memory space, which allows them to communicate and share data more easily. Multithreading is suitable for applications that require a high degree of interactivity and responsiveness, such as user interfaces or network servers. In multithreading, multiple threads are executed concurrently within the same process and are scheduled by the operating system's thread scheduler. Multithreading can provide improved performance when dealing with I/O-bound tasks, as threads can be blocked while waiting for input/output operations to complete. Multiprocessing:

Multiprocessing involves the execution of multiple processes simultaneously, where each process has its own memory space. Processes are heavyweight compared to threads since they require separate memory resources and system overhead for communication between processes. Multiprocessing is suitable for applications that require parallel processing and can benefit from utilizing multiple CPUs or CPU cores. In multiprocessing, multiple processes run independently of each other and can be scheduled by the operating system's process scheduler. Multiprocessing can provide improved performance when dealing with CPU-bound tasks, as each process can be executed on a separate CPU core. In summary, multithreading focuses on concurrent execution within a single process using lightweight threads, while multiprocessing involves the simultaneous execution of multiple processes, each with its own memory space. The choice between multithreading and multiprocessing depends on the nature of the application, the type of tasks to be performed, and the available hardware resources.

In the code snippets above we are performing iterations 999999 to perform a calculation(x=5**999) using multithreading and multiprocessing.We used two threads for multithreading and the time taken for the calculatiojn is 4.79 s while for multiprocessing time taken was 4.59 s.Since the task here is computational intensive and is beneficial from parallel execution across multiple cores multiprocessing seems better
"""

import subprocess

def add_numbers(num1, num2):
    # Construct the curl command to execute the API
    curl_command = f'curl -X POST -H "Content-Type: application/json" -d \'{{"number1": {num1}, "number2": {num2}}}\'' \
                   ' https://api.example.com/add'

    # Execute the curl command using subprocess
    result = subprocess.run(curl_command, shell=True, capture_output=True, text=True)

    # Check if the API call was successful
    if result.returncode == 0:
        # Extract the result from the API response
        response = result.stdout.strip()
        return int(response)
    else:
        # Handle API call failure
        print(f'API call failed with error: {result.stderr}')
        return None

# Test the add_numbers function
result = add_numbers(5, 3)
if result is not None:
    print(f'The sum of 5 and 3 is: {result}')